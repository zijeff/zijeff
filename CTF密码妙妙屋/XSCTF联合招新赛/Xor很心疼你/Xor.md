# XSCTF联合招新赛 CRYPTO方向 Xor很心疼你

by zijeff

代码的加密逻辑比较简单，就是利用生成的随机数来生成tmp，从而对flag中逐字符进行异或运算。

而异或运算我们都知道是可逆的，所以解决问题的关键在于找到异或运算时用到的tmp值。

同时程序在正式进行加密操作之前，做了20次循环来更新key值。

```python
def f(x):
    random.seed(x)
    return random.getrandbits(8)
for _ in range(20):
        key = f(key)
        assert key != 0
```

根据程序中函数的定义，输入一个数x作为随机数种子，并返回一个8位的随机数。也就意味着不管我初始给的key多大，做完20次循环后开始加密时，key的值一定介于0到255之间。而又因为，随机数生成种子确定了，那么之后生成的随机数序列也确定了。

所以我们可以采用爆破的方式，遍历所有可能的组合，找到含有hsctf字符串的结果，也就找到了答案。

（PS：爆破略微有点耗时，大概两三分钟吧。结果是：***hsctf{x0r_i5_v4ry@eAsy_1oakn29gm3m3k93}***）