## SWPUCTF 2021 新生赛 Crypto4

***by zijeff***

emm，这种类型的题目如果见过了就比较好处理了，一个简单的近似处理问题，还是先看题目吧。

```python
p = getPrime(512)
q = next_prime(p)
m1 = bytes_to_long(bytes(flag.encode()))
```

从这段代码我们不难看出，题目对于p和q的选取是先生成一个，再去寻找这个质数的下一个。

那么也就意味着这两个质数之间只是相差了一个常数，我们不妨将其记为C，那么我们就有如下等式。
$$
q = p + C
$$

$$
n = pq = p(p+C) = p^2+Cp
$$

我们接下来就可以进行近似处理的问题了，注意到p是512位的质数，那么在平方之后将对表达式的值起到主导作用。简而言之，我们可以忽略线性部分，将其近似处理后得到如下式子。
$$
n \approx p^2
$$
所以，简单处理一下就有：
$$
p \approx \sqrt n
$$
综上所述，我们不妨直接对n开方，然后在开方之后得整数附近区间遍历，就有很大可能找到p，从而确定q。

所以，具体代码如下：

```python
import gmpy2
from tqdm import *
from Crypto.Util.number import *

c = 10227915341268619536932290456122384969242151167487654201363877568935534996454863939953106193665663567559506242151019201314446286458150141991211233219320700112533775367958964780047682920839507351492644735811096995884754664899221842470772096509258104067131614630939533042322095150722344048082688772981180270243
n = 52147017298260357180329101776864095134806848020663558064141648200366079331962132411967917697877875277103045755972006084078559453777291403087575061382674872573336431876500128247133861957730154418461680506403680189755399752882558438393107151815794295272358955300914752523377417192504702798450787430403387076153
e = 65537

k = gmpy2.iroot(n, 2)[0]
for i in trange(k-100000, k+100000):
    if isPrime(i) and n%i == 0:
        p = i
        q = n//i
        break
print(p)
print(q)
phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
```

得出p，q之后就是常规的求解RSA了，最后得到flag：

***NSSCTF{no_why}***