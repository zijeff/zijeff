# RSA共模攻击的数学证明

***by zijeff***

### 问题导入

相信看到这里的你已经对RSA加密系统有了一个基本的认识，你知道了RSA加密是如何对一段消息加密，又是如何对得到的密文进行解密，也应该明白了RSA中的常见参数，例如公钥指数e，私钥指数d等等。

回顾RSA的解密，我们需要的是私钥指数d，一旦有了私钥指数d，那么就可以解决问题。本质上求解私钥指数d就是在尝试质因数分解n，而在数学上这是一件困难的事。

那么我们有没有什么方法可以在**不分解n的情况下得到明文**呢？

***有的兄弟有的！***这就是RSA共模攻击，共模攻击加强了条件，具体是这样的：

消息发送者在发送同一段明文m时采用了不同的公钥加密指数e和相同的模数n时，我们可以不通过分解模数n得到明文m。

### 证明如下

首先我们记明文为m，两次加密使用的公钥加密指数分别为e1和e2，对应的密文分别为c1和c2，模数为n。

那么根据RSA的加密方法，得到下面二式：
$$
c_1 \equiv m^{e_1} \mod n
\\c_2 \equiv m^{e_2} \mod n
$$
又因为根据扩展欧几里得算法存在着两个整数记为s1和s2，满足下式：
$$
e_1s_1 + e_2s_2 = gcd(e_1,e_2)
$$
（注：gcd(e1,e2)表示的是e1和e2的最大公因数，有些书上也用(e1,e2)来表示，两种写法均表示为e1和e2的最大公因数。）

对上面的式子做一下代数变换，得到如下的式子：
$$
c_1^{s_1} \equiv m^{e_1s_1} \mod n
\\c_2^{s_2} \equiv m^{e_2s_2} \mod n
$$
上述两式相乘得到：
$$
c_1^{s_1}c_2^{s_2} \equiv m^{e_1s_1 + e_2s_2} \equiv m^{gcd(e1,e2)} \mod n
$$
c1和c2已知，s1，s2和e1和e2的最大公因数可以用扩展欧几里得算法求得，模数n题目已经给出，所以上述式中的m可以被唯一确定地解出。

**证毕**

### 运用技巧

CTF中常见的是e1和e2互质，即公因数为1，这个时候就可以直接求得m了。如果最大公因数不为1，那就不要忘了，在最后求得答案时开方求得精确解。